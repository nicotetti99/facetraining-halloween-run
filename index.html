<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FaceTraining Halloween Run â€“ Gothic Edition</title>
<style>
  body { margin: 0; background: #0f0a24; color: #fff; text-align: center; font-family: monospace; }
  h1 { margin-top: 10px; }
  canvas { background: #1a0d2e; border: 2px solid #fff; display: block; margin: 20px auto; }
  #game-over { display: none; font-size: 24px; margin-top: 20px; }
  button { padding: 8px 16px; font-size: 16px; }
</style>
</head>
<body>
<h1>Halloween Gothic Run</h1>
<canvas id="game" width="800" height="400"></canvas>
<div id="game-over">
  <p>Gioco terminato! Punteggio: <span id="score-output"></span></p>
  <button onclick="resetGame()">Rigioca</button>
</div>
<script>
// Canvas setup
const canvas  = document.getElementById('game');
const ctx     = canvas.getContext('2d');
const width   = canvas.width;
const height  = canvas.height;

// Player (Veronica) properties
const player = {
  x: 80,
  y: height - 80,
  width: 40,
  height: 60,
  velocityY: 0,
  gravity: 0.7,
  jumpForce: 14,
  onGround: true
};

// Obstacles (ghosts)
let obstacles = [];
let obstacleTimer = 0;
const obstacleInterval = 90; // spawn every ~90 frames

// Game state
let score = 0;
let gameOver = false;

// Keyboard/touch input
document.addEventListener('keydown', (e) => {
  if ((e.code === 'Space' || e.code === 'ArrowUp') && player.onGround && !gameOver) {
    player.velocityY = -player.jumpForce;
    player.onGround = false;
  }
});
canvas.addEventListener('touchstart', () => {
  if (player.onGround && !gameOver) {
    player.velocityY = -player.jumpForce;
    player.onGround = false;
  }
});

// Main game loop
function update() {
  if (gameOver) return;
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  drawBackground();

  // Update player position
  player.velocityY += player.gravity;
  player.y += player.velocityY;
  if (player.y + player.height >= height - 20) {
    player.y = height - 20 - player.height;
    player.velocityY = 0;
    player.onGround = true;
  }

  // Draw player (16-bit Veronica)
  drawPlayer();

  // Spawn obstacles
  obstacleTimer++;
  if (obstacleTimer >= obstacleInterval) {
    obstacleTimer = 0;
    const size = 50;
    obstacles.push({
      x: width,
      y: height - 20 - size,
      width: size,
      height: size
    });
  }

  // Update and draw obstacles
  obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
  obstacles.forEach((obs) => {
    obs.x -= 5; // move left
    drawGhost(obs.x, obs.y, obs.width, obs.height);
    // Collision detection
    if (
      player.x < obs.x + obs.width &&
      player.x + player.width > obs.x &&
      player.y < obs.y + obs.height &&
      player.y + player.height > obs.y
    ) {
      endGame();
    }
  });

  // Update score
  score++;
  ctx.fillStyle = '#ffffff';
  ctx.font = '16px monospace';
  ctx.fillText('Punteggio: ' + score, 10, 20);

  requestAnimationFrame(update);
}

// Draw gothic background with moon and pumpkins
function drawBackground() {
  // sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, height);
  gradient.addColorStop(0, '#1a0d2e');
  gradient.addColorStop(1, '#0f0a24');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);

  // moon
  ctx.fillStyle = '#ddd';
  ctx.beginPath();
  ctx.arc(width - 80, 80, 40, 0, 2 * Math.PI);
  ctx.fill();

  // ground
  ctx.fillStyle = '#2f204b';
  ctx.fillRect(0, height - 20, width, 20);
}

// Draw Veronica as 16-bit pixel art figure
function drawPlayer() {
  const { x, y, width: w, height: h } = player;
  // Draw head (hair)
  ctx.fillStyle = '#3f2b56'; // hair dark purple
  ctx.fillRect(x + 5, y, w - 10, h * 0.3);
  ctx.fillStyle = '#ffccaa'; // skin color
  ctx.fillRect(x + 10, y + h * 0.05, w - 20, h * 0.2);
  // Draw body/shirt
  ctx.fillStyle = '#7268a6';
  ctx.fillRect(x + 5, y + h * 0.3, w - 10, h * 0.4);
  // Shirt text 'Veronica'
  ctx.fillStyle = '#ffffff';
  ctx.font = '10px monospace';
  ctx.fillText('Veronica', x - 2, y + h * 0.55);
  // Draw legs
  ctx.fillStyle = '#3f2b56';
  ctx.fillRect(x + 8, y + h * 0.7, w - 16, h * 0.3);
}

// Draw ghost obstacles
function drawGhost(x, y, width, height) {
  // body
  ctx.fillStyle = '#4d2e94';
  ctx.beginPath();
  ctx.arc(x + width / 2, y + height * 0.4, width / 2, Math.PI, 2 * Math.PI);
  ctx.rect(x, y + height * 0.4, width, height * 0.6);
  ctx.fill();

  // eyes
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(x + width * 0.3, y + height * 0.5, 5, 0, 2 * Math.PI);
  ctx.arc(x + width * 0.7, y + height * 0.5, 5, 0, 2 * Math.PI);
  ctx.fill();

  // creepy smile
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x + width / 2, y + height * 0.65, width * 0.25, 0, Math.PI);
  ctx.stroke();
}

// End game
function endGame() {
  gameOver = true;
  document.getElementById('score-output').textContent = score;
  document.getElementById('game-over').style.display = 'block';
}

// Reset game
function resetGame() {
  score = 0;
  gameOver = false;
  player.y = height - 80;
  player.velocityY = 0;
  obstacles = [];
  document.getElementById('game-over').style.display = 'none';
  update();
}

// Start game
update();
</script>
</body>
</html>
